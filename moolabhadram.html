<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>മൂലഭദ്രം രഹസ്യ ഭാഷാ സഹായി</title>
</head>
<body>
<center>
    <h3>മലയാളത്തിൽ നിന്നും രഹസ്യഭാഷയായ മൂലഭദ്രത്തിലേക്കും തിരിച്ചും മാറ്റാം</h3>
    <br/>
    <div>
        <table>
            <tr>
                <td>
                    <h5>'ന', 'ന്ന' സ്വരങ്ങൾക്ക് അവ്യക്തത വന്നേക്കാവുന്ന വാക്കുകൾ മാറ്റുമ്പോൾ ഇവയിൽ ഒന്ന് തിരഞ്ഞെടുക്കുക</h5>
                </td>
            </tr>
            <tr>
                <td>
                    <input type="radio" id="innale" name="nna_swaram" value="innale" checked>
                    <label for="innale">'നഗരം', 'ഇന്നലെ' പോലുള്ള വാക്കുകളിലെ 'ന', 'ന്ന' സ്വരങ്ങൾക്ക് മുൻഗണന</label><br>
                    <input type="radio" id="pinne" name="nna_swaram" value="pinne">
                    <label for="pinne">'പാനീയം', 'പിന്നെ' പോലുള്ള വാക്കുകളിലെ 'ന', 'ന്ന' സ്വരങ്ങൾക്ക് മുൻഗണന</label><br>
                </td>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
            </tr>
        </table>
    </div>
    <br/>
    <br/>
    <br/>
    <div>
        <textarea id="plain" name="plain" placeholder="മാറ്റാനുള്ള വാക്കുകളോ വാചകങ്ങളോ ഇവിടെ എഴുതുക" rows="10"
                  cols="100"></textarea>
    </div>
    <br/>
    <div>
        <table>
            <tr>
                <td>
                    <input type="radio" id="to_moolabhadram" name="direction" value="to_moolabhadram" checked>
                    <label for="to_moolabhadram">മൂലഭദ്രത്തിലേക്ക്</label><br>
                    <input type="radio" id="to_malayalam" name="direction" value="to_malayalam">
                    <label for="to_malayalam">മലയാളത്തിലേക്ക്</label><br>
                </td>
                <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
                <td>
                    <button onclick="convert()">മാറ്റുക</button>
                </td>
            </tr>
        </table>
    </div>
    <br/>
    <br/>
    <div>
        <textarea readonly id="cipher" name="cipher" placeholder="ഉത്തരം" rows="10" cols="100"></textarea>
    </div>
    <br/>
    <br/>
    <div>
        <p>മൂലഭദ്രത്തെപ്പറ്റി കൂടുതൽ അറിയാം: <a href="https://en.wikipedia.org/wiki/Mulabhadra"
                                                target="_blank">Wikipedia</a>,
            <a href="https://www.youtube.com/watch?v=9o-0oBqP2pU" target="_blank">YouTube</a></p>
    </div>
    <div>
        <p>മലയാളം അക്ഷരങ്ങൾ: <a href="https://unicode.org/charts/PDF/U0D00.pdf" target="_blank">Unicode</a></p>
    </div>
    <footer>
        <small>&copy; Copyright 2020, <a href="https://www.facebook.com/rajneeshk7"
                                         target="_blank">Rajneesh Kesavan</a>
            <br/>Source code on <a href="https://github.com/rajneeshk7/moolabhadram"
               target="_blank">github</a></small>
    </footer>
</center>
<script language="JavaScript">
        //Convert individual Malayalam unicode characters or sequences by mapping them to another unicode character
        //or sequence according to Moolabhadram rules
        let basicMap = new Map([
            ['\u0D05', '\u0D15'], //a  -> ka
            ['\u0D06', '\u0D15\u0D3E'], //aa -> kaa
            ['\u0D07', '\u0D15\u0D3F'], //i  -> ki
            ['\u0D08', '\u0D15\u0D40'], //ii -> kii
            ['\u0D09', '\u0D15\u0D41'], //u  -> ku
            ['\u0D0A', '\u0D15\u0D42'], //uu -> kuu
            ['\u0D0B', '\u0D15\u0D43'], //Ru -> kRu
            ['\u0D0E', '\u0D15\u0D46'], //e  -> ke
            ['\u0D0F', '\u0D15\u0D47'], //E  -> kE
            ['\u0D10', '\u0D15\u0D48'], //ai -> kai
            ['\u0D12', '\u0D15\u0D4A'], //o  -> ko
            ['\u0D13', '\u0D15\u0D4B'], //O  -> kO
            ['\u0D14', '\u0D15\u0D4C'], //ou -> kou

            ['\u0D15', '\u0D05'], //ka   -> a
            ['\u0D16', '\u0D17'], //kha  -> ga
            ['\u0D17', '\u0D16'], //ga   -> kha
            ['\u0D18', '\u0D19'], //gha  -> nga
            ['\u0D19', '\u0D18'], //nga  -> gha

            ['\u0D1A', '\u0D1F'], //cha   -> ta
            ['\u0D1B', '\u0D20'], //chha  -> TTa
            ['\u0D1C', '\u0D21'], //ja    -> da
            ['\u0D1D', '\u0D22'], //jha   -> DDa
            ['\u0D1E', '\u0D23'], //nja   -> Na

            ['\u0D1F', '\u0D1A'], //ta   -> cha
            ['\u0D20', '\u0D1B'], //TTa  -> chha
            ['\u0D21', '\u0D1C'], //da    -> ja
            ['\u0D22', '\u0D1D'], //DDa   -> jha
            ['\u0D23', '\u0D1E'], //Na    -> nja

            ['\u0D24', '\u0D2A'], //tha   -> pa
            ['\u0D25', '\u0D2B'], //thha  -> pha
            ['\u0D26', '\u0D2C'], //da   -> ba
            ['\u0D27', '\u0D2D'], //dha  -> bha
            ['\u0D28', '\u0D2E'], //na   -> ma

            ['\u0D2A', '\u0D24'], //pa   -> tha
            ['\u0D2B', '\u0D25'], //pha  -> thha
            ['\u0D2C', '\u0D26'], //ba   -> da
            ['\u0D2D', '\u0D27'], //bha  -> dha
            ['\u0D2E', '\u0D28'], //ma   -> na

            ['\u0D2F', '\u0D36'], //ya   -> sha
            ['\u0D30', '\u0D37'], //ra  -> Sha
            ['\u0D32', '\u0D38'], //la   -> sa
            ['\u0D35', '\u0D39'], //va  -> ha
            ['\u0D36', '\u0D2F'], //sha   -> ya
            ['\u0D37', '\u0D30'], //Sha   -> ra
            ['\u0D38', '\u0D32'], //sa   -> la
            ['\u0D39', '\u0D35'], //ha   -> va
            ['\u0D33', '\u0D15\u0D4D\u0D37'], //La   -> kSha
            ['\u0D31', '\u0D34'], //Ra   -> zha
            ['\u0D34', '\u0D31'], //zha  -> Ra

            //chill aksharangal
            ['\u0D7D', '\u0D2A\u0D4D'], //ll -> p
            ['\u0D7B', '\u0D31\u0D4D\u0D31\u0D4D'], //nn -> tt
            ['\u0D7C', '\u0D37\u0D4D'], //RR -> Sh
            ['\u0D7E', '\u0D15\u0D4D\u0D37\u0D4D'] //LL -> kSh
        ]);

        //Map to handle the special case of ka with dependent vowel signs. like ki, kii, ku, kuu, ... kSha etc.
        let kMap = new Map([
            ['\u0D15\u0D3E', '\u0D06'], //kaa  -> aa
            ['\u0D15\u0D3F', '\u0D07'], //ki   -> i
            ['\u0D15\u0D40', '\u0D08'], //kii  -> ii
            ['\u0D15\u0D41', '\u0D09'], //ku   -> u
            ['\u0D15\u0D42', '\u0D0A'], //kuu  -> uu
            ['\u0D15\u0D43', '\u0D0B'], //kRu  -> Ru
            ['\u0D15\u0D46', '\u0D0E'], //ke   -> e
            ['\u0D15\u0D47', '\u0D0F'], //kE   -> E
            ['\u0D15\u0D48', '\u0D10'], //kai  -> ai
            ['\u0D15\u0D4A', '\u0D12'], //ko   -> o
            ['\u0D15\u0D4B', '\u0D13'], //kO   -> O
            ['\u0D15\u0D4C', '\u0D14'], //kou  -> ou
            ['\u0D15\u0D4D\u0D37', '\u0D33'] //kSha -> La
        ]);

        //Set to hold all dependent vowel signs
        const dependentVowels = new Set();
        dependentVowels.add('\u0D3E'); //aa
        dependentVowels.add('\u0D3F'); //i
        dependentVowels.add('\u0D40'); //ii
        dependentVowels.add('\u0D41'); //u
        dependentVowels.add('\u0D42'); //uu
        dependentVowels.add('\u0D43'); //Ru
        dependentVowels.add('\u0D46'); //e
        dependentVowels.add('\u0D47'); //E
        dependentVowels.add('\u0D48'); //ai
        dependentVowels.add('\u0D4A'); //o
        dependentVowels.add('\u0D4B'); //O
        dependentVowels.add('\u0D4C'); //ou

        var plainText = document.getElementById("plain").value;
        var forward = true;
        var forcePinneStyle = false;
        var cipherText = '';

        var whiteSpace = true;
        var firstLetterInWord = true;

        var kState = 'not detected'; //'not detected', 'k found', 'ku found', 'kSh found'
        var RState = 'not detected'; //'not detected', 'R found', 'Ru found', 'tt found'
        var nState = 'not detected'; //'not detected', 'n found first', 'n found', 'nu found first', 'nu found', 'nn found'

        var cIsUsed = false;

        function convert() {
            plainText = document.getElementById("plain").value;
            forward = document.getElementById("to_moolabhadram").checked;
            forcePinneStyle = document.getElementById("pinne").checked;
            cipherText = '';

            whiteSpace = true;
            firstLetterInWord = true;

            kState = 'not detected';
            RState = 'not detected';
            nState = 'not detected';

            const tokens = Array.from(plainText);

            for (let i = 0; i < tokens.length; i++) {
                var c = tokens[i]; //read one unicode character
                cIsUsed = false;

                //store whether previous c is whitespace or not
                firstLetterInWord = whiteSpace;

                //store whether current c is whitespace or not
                whiteSpace = (c.trim().length == 0);

                if (c == '\u0D15') { // ക
                    if (RState != 'not detected') {
                        cleanupR(c);
                    }
                    if (nState != 'not detected') {
                        cleanupN(c);
                    }
                    if (kState == 'k found') { //another ka came right next. convert the first ka to a
                        cipherText += '\u0D05'; //ka -> a
                        continue;
                    }
                    if (kState == 'not detected') {
                        kState = 'k found';
                        continue;
                    }
                }
                if (c == "\u0D31") { // റ
                    if (kState != 'not detected') {
                        cleanupK(c);
                    }
                    if (nState != 'not detected') {
                        cleanupN(c);
                    }
                    if (RState == 'R found') { //another Ra came right next. convert the first Ra to zha
                        cipherText += '\u0D34'; //Ra -> zha
                        continue;
                    }
                    if (RState == 'not detected') {
                        RState = 'R found';
                        continue;
                    }
                    if (RState == 'Ru found') {
                        RState = 'tt found';
                        continue;
                    }
                    if (RState == 'tt found') {
                        cipherText += '\u0D28'; //tta -> na
                        RState = 'R found';
                        continue;
                    }
                }

                //na to tta : for words like പന, ആന
                //na to ma : for words like നഗരം, നിശ
                if (c == '\u0D28') { // ന
                    if (kState != 'not detected') {
                        cleanupK(c);
                    }
                    if (RState != 'not detected') {
                        cleanupR(c);
                    }
                    if (!forward) { //reverse i.e, Moolabhadram to Malayalam
                        if (forcePinneStyle) {
                            cipherText += '\u0D31\u0D4D\u0D31'; //na -> tta
                        } else {
                            cipherText += '\u0D2E'; //na -> ma
                        }
                        nState = 'not detected';
                        continue;
                    }
                    if (nState == 'n found first') { //another na came right next. convert the first na to ma
                        cipherText += '\u0D2E'; //na -> ma
                        continue;
                    }
                    if (nState == 'n found') { //another na came right next. convert the first na to tta
                        cipherText += '\u0D31\u0D4D\u0D31'; //na -> tta
                        continue;
                    }
                    if (nState == 'not detected') {
                        if (firstLetterInWord) {
                            nState = 'n found first';
                        } else {
                            nState = 'n found';
                        }
                        continue;
                    }
                    if (nState == 'nu found first' || nState == 'nu found') {
                        nState = 'nn found';
                        if (forcePinneStyle) {
                            cipherText += '\u0D31\u0D4D\u0D31\u0D4D\u0D31\u0D4D\u0D31'; //nna -> tttta
                        } else {
                            cipherText += '\u0D2E\u0D4D\u0D2E'; //nna -> mma
                        }
                        nState = 'not detected';
                        continue;
                    }
                }

                if (c == '\u0D37') { //Sh
                    if (RState != 'not detected') {
                        cleanupR(c);
                    }
                    if (nState != 'not detected') {
                        cleanupN(c);
                    }
                    if (kState == 'ku found') {
                        kState = 'kSh found';
                        continue;
                    }
                }

                if (c == '\u0D4D') { //chandrakkala
                    if (kState == 'k found') {
                        kState = 'ku found';
                        continue;
                    }
                    if (kState == 'kSh found') {
                        if (forward) {
                            cipherText += '\u0D33\u0D4D'; //L
                        } else {
                            cipherText += '\u0D7E'; //LL
                        }
                        kState = 'not detected';
                        continue;
                    }
                    if (RState == 'R found') {
                        RState = 'Ru found';
                        continue;
                    }
                    if (RState == 'tt found') {
                        if (forward) {
                            cipherText += '\u0D28\u0D4D'; //nu
                        } else {
                            cipherText += '\u0D7B'; //nn
                        }
                        RState = 'not detected';
                        continue;
                    }
                    if (nState == 'n found first') {
                        nState = 'nu found first';
                        continue;
                    }
                    if (nState == 'n found') {
                        nState = 'nu found';
                        continue;
                    }
                }

                cleanupK(c);
                cleanupR(c);
                cleanupN(c);

                if (!cIsUsed) {
                    cipherText += getFromBasicMap(c);
                }
            }

            document.getElementById("cipher").value = cipherText;
        }

        function cleanupK(c) {
            if (kState == 'k found') {
                if (dependentVowels.has(c)) {
                    cipherText += kMap.get('\u0D15' + c); //Map ki, kii ... to i, ii ...
                    cIsUsed = true;
                } else {
                    cipherText += '\u0D05'; //ka -> a
                }
            } else if (kState == 'ku found') {
                cipherText += '\u0D05\u0D4D'; //ka + chandrakkala -> a + chandrakkala
            } else if (kState == 'kSh found') {
                cipherText += '\u0D33'; //L + mapping of next char
            }
            kState = 'not detected';
        }

        function cleanupR(c) {
            if (RState == 'R found') {
                cipherText += '\u0D34'; //Ra -> zha
            } else if (RState == 'Ru found') {
                cipherText += '\u0D34\u0D4D'; //Ra + chandrakkala -> zha + chandrakkala
            } else if (RState == 'tt found') {
                cipherText += '\u0D28'; //tta -> na
            }
            RState = 'not detected';
        }

        function cleanupN(c) {
            if (nState == 'n found first') {
                cipherText += '\u0D2E'; //na -> ma
            } else if (nState == 'n found') {
                if (forward) {
                    cipherText += '\u0D31\u0D4D\u0D31'; //na -> tta
                } else {
                    cipherText += '\u0D2E'; //na -> ma
                }
            } else if (nState == 'nu found first') {
                cipherText += '\u0D2E\u0D4D'; //na + chandrakkala -> ma + chandrakkala
            } else if (nState == 'nu found') {
                if (forward) {
                    cipherText += '\u0D31\u0D4D\u0D31\u0D4D'; //na + chandrakkala -> tta + chandrakkala
                } else {
                    cipherText += '\u0D2E\u0D4D'; //na + chandrakkala -> ma + chandrakkala
                }
            }
            nState = 'not detected';
        }

        function getFromBasicMap(c) {
            if (basicMap.has(c)) {
                return basicMap.get(c);
            }
            return c;
        }
</script>

</body>
</html>